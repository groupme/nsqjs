// Generated by CoffeeScript 1.6.3
var EventEmitter, NSQDConnection, Reader, ReaderConfig, ReaderRdy, RoundRobinList, lookup, request, _,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = require('underscore');

request = require('request');

EventEmitter = require('events').EventEmitter;

ReaderConfig = require('./config').ReaderConfig;

NSQDConnection = require('./nsqdconnection').NSQDConnection;

ReaderRdy = require('./readerrdy').ReaderRdy;

RoundRobinList = require('./roundrobinlist');

lookup = require('./lookupd');

Reader = (function(_super) {
  __extends(Reader, _super);

  Reader.ERROR = 'error';

  Reader.MESSAGE = 'message';

  Reader.DISCARD = 'discard';

  Reader.NSQD_CONNECTED = 'nsqd_connected';

  Reader.NSQD_CLOSED = 'nsqd_closed';

  function Reader(topic, channel, options) {
    this.topic = topic;
    this.channel = channel;
    this.config = new ReaderConfig(options);
    this.config.validate();
    this.roundrobinLookupd = new RoundRobinList(this.config.lookupdHTTPAddresses);
    this.readerRdy = new ReaderRdy(this.config.maxInFlight, this.config.maxBackoffDuration);
    this.connectIntervalId = null;
    this.connectionIds = [];
  }

  Reader.prototype.connect = function() {
    var delay, delayedStart, directConnect, interval,
      _this = this;
    interval = this.config.lookupdPollInterval * 1000;
    delay = Math.random() * this.config.lookupdPollJitter * interval;
    if (this.config.nsqdTCPAddresses.length) {
      directConnect = function() {
        var addr, address, port, _i, _len, _ref, _ref1, _results;
        if (_this.isPaused()) {
          return;
        }
        if (_this.connectionIds.length < _this.config.nsqdTCPAddresses.length) {
          _ref = _this.config.nsqdTCPAddresses;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            addr = _ref[_i];
            _ref1 = addr.split(':'), address = _ref1[0], port = _ref1[1];
            _results.push(_this.connectToNSQD(address, Number(port)));
          }
          return _results;
        }
      };
      delayedStart = function() {
        return _this.connectIntervalId = setInterval(directConnect.bind(_this), interval);
      };
      directConnect();
      return setTimeout(delayedStart, delay);
    } else {
      delayedStart = function() {
        return _this.connectIntervalId = setInterval(_this.queryLookupd.bind(_this), interval);
      };
      this.queryLookupd();
      return setTimeout(delayedStart, delay);
    }
  };

  Reader.prototype.close = function() {
    clearInterval(this.connectIntervalId);
    return this.readerRdy.close();
  };

  Reader.prototype.pause = function() {
    return this.readerRdy.pause();
  };

  Reader.prototype.unpause = function() {
    return this.readerRdy.unpause();
  };

  Reader.prototype.isPaused = function() {
    return this.readerRdy.paused;
  };

  Reader.prototype.queryLookupd = function() {
    var endpoint,
      _this = this;
    if (this.isPaused()) {
      return;
    }
    endpoint = this.roundrobinLookupd.next();
    return lookup(endpoint, this.topic, function(err, nodes) {
      var n, _i, _len, _results;
      if (!err) {
        _results = [];
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          n = nodes[_i];
          _results.push(_this.connectToNSQD(n.broadcast_address, n.tcp_port));
        }
        return _results;
      }
    });
  };

  Reader.prototype.connectToNSQD = function(host, port) {
    var conn, connectionId,
      _this = this;
    connectionId = "" + host + ":" + port;
    if (this.connectionIds.indexOf(connectionId) !== -1) {
      return;
    }
    this.connectionIds.push(connectionId);
    conn = new NSQDConnection(host, port, this.topic, this.channel, this.config);
    conn.on(NSQDConnection.CONNECTED, function() {
      return _this.emit(Reader.NSQD_CONNECTED, host, port);
    });
    conn.on(NSQDConnection.ERROR, function(err) {
      return _this.emit(Reader.ERROR, err);
    });
    conn.on(NSQDConnection.CONNECTION_ERROR, function(err) {
      return _this.emit(Reader.ERROR, err);
    });
    conn.on(NSQDConnection.CLOSED, function() {
      var index;
      index = _this.connectionIds.indexOf(connectionId);
      if (index === -1) {
        return;
      }
      _this.connectionIds.splice(index, 1);
      return _this.emit(Reader.NSQD_CLOSED, host, port);
    });
    conn.on(NSQDConnection.MESSAGE, function(message) {
      return process.nextTick(function() {
        if (message.attempts < _this.config.maxAttempts) {
          return _this.emit(Reader.MESSAGE, message);
        } else {
          return _this.emit(Reader.DISCARD, message);
        }
      });
    });
    this.readerRdy.addConnection(conn);
    return conn.connect();
  };

  return Reader;

})(EventEmitter);

module.exports = Reader;
